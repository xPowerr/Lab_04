;---------------------------------------------------
;Universidad del Valle de Guatemala
;IE2023 Programación de Microncontroladores
;Autor: Gabriel Carrera 21216
;Compilador: PIC-AS (v2.40), MPLAB X IDE (v6.00)
;Proyecto: Laboratorio 4
;Creado: 14/02/2023
;Última Modificación: 17/02/2023
;---------------------------------------------------
PROCESSOR 16F887
#include <xc.inc>
;---------------------------------------------------
;Palabra de Configuración
;---------------------------------------------------
    
; CONFIG1
  CONFIG  FOSC = INTRC_NOCLKOUT   ; Oscillator Selection bits (INTOSC oscillator: CLKOUT function on RA6/OSC2/CLKOUT pin, I/O function on RA7/OSC1/CLKIN)
  CONFIG  WDTE = OFF              ; Watchdog Timer Enable bit (WDT disabled and can be enabled by SWDTEN bit of the WDTCON register)
  CONFIG  PWRTE = OFF             ; Power-up Timer Enable bit (PWRT disabled)
  CONFIG  MCLRE = OFF             ; RE3/MCLR pin function select bit (RE3/MCLR pin function is digital input, MCLR internally tied to VDD)
  CONFIG  CP = OFF                ; Code Protection bit (Program memory code protection is disabled)
  CONFIG  CPD = OFF               ; Data Code Protection bit (Data memory code protection is disabled)
  CONFIG  BOREN = OFF             ; Brown Out Reset Selection bits (BOR controlled by SBOREN bit of the PCON register)
  CONFIG  IESO = OFF              ; Internal External Switchover bit (Internal/External Switchover mode is disabled)
  CONFIG  FCMEN = OFF             ; Fail-Safe Clock Monitor Enabled bit (Fail-Safe Clock Monitor is disabled)
  CONFIG  LVP = OFF               ; Low Voltage Programming Enable bit (RB3 pin has digital I/O, HV on MCLR must be used for programming)

; CONFIG2
  CONFIG  BOR4V = BOR40V          ; Brown-out Reset Selection bit (Brown-out Reset set to 4.0V)
  CONFIG  WRT = OFF               ; Flash Program Memory Self Write Enable bits (Write protection off)
  
 ;-------------- Variables ----------
PSECT udata_shr
    condicion: DS 1 ; 1 BYTE, para los antirrebotes
    TMR0_DISP: DS 1 ; 1 BYTE, para el display en segundos
    TMR0_UNIDADES: DS 1 ; 1 BYTE, para el display en unidades 
    TMR0_DECENAS: DS 1 ; 1 BYTE, para el display en decenas
    W_TEMP: DS 1       ; 1 BYTE, para interrupciones
    STATUS_TEMP: DS 1  ; 1 BYTE, para interrupciones
    UP	 EQU 6 ; DECLARAMOS CONSTANTES PARA LOS PUERTOS DE LOS BOTONES
    DOWN EQU 7
    
 
 ;-------------- Vector RESET ----------
PSECT resVect, class=CODE, abs, delta=2
ORG 00h ; posición 0000h para el reset 
resetVect:
    PAGESEL main
    goto main 

;----------- Interrupciones ----------
PSECT intVect, class=CODE, abs, delta=2
ORG 04h ; posición 0004h para las interrupciones
    
PUSH:
    MOVWF W_TEMP	    ;PONER EL VALOR DEL W EN EN W_TEMP, ES DECIR LA VARIABLE TEMPORAL
    SWAPF STATUS, W	    ;HACER SWAP Y GUARDAR EN W PARA NO ALTERAR LA ZERO FLAG
    MOVWF STATUS_TEMP	    ;MOVER EL VALOR DE W EN LA OTRA VARIABLE TEMPORAL
ISR:  
    BTFSC RBIF		    ;REVISAR EL BIT DE INTERRUPCIONES DEL PUERTO B
    CALL INT_RB		    ;IR A LA SUBRUTINA DE PORTB
    BTFSC INTCON, 2	    ;REVISAR EL BIT DE INTERRUPCIONES DEL Timer0
    CALL INT_TMR0	    ;IR A LA SUBRUTINA DEL TMR0
POP:
    SWAPF STATUS_TEMP, W    ;CAMBIAR EL VALOR DE STATUS CON W
    MOVWF STATUS	    ;CARGAR EL VALOR DEL STATUS, ES DECIR, W A STaTUS
    SWAPF W_TEMP, F	    ;CAMBIAR STATUS_TEMP DE W A F PARA QUE ESTEN EN ORDEN AL MOVERLOS
    SWAPF W_TEMP, W	    ;MOVER EL VALOR DE W A W, SE ROTA DE NUEVO PARA NO MODIFICAR EL ORDEN Y GUARDAR EN W
    RETFIE		    ;REGRESAR DE LA INTERRUPCION
 
;----------- Subrutinas  interrupciones --------------
INT_RB:
    BANKSEL PORTA
    
    ; FUNCIONAMIENTO DEL INCREMENTO
    BTFSC PORTB, UP ; CHEQUEAR SI BOTON RA0 SE ENCUENTRA PRESIONADO, SI NO, SALTAR CON NOP
    call ANTIREBOTE1 ; LLAMAR AL ANTIREBOTE
    BTFSS PORTB, UP ; VERIFICAR SI YA SE DEJO DE PRESIONAR RA0
    call INCREMENTO ; SI YA SE DEJO DE PRESIONAR, LLAMAR A FUNCION DE INCREMENTO
    
    ; FUNCIONAMIENTO DEL DECREMENTO
    BTFSC PORTB, DOWN ; CHEQUEAR SI BOTON RA0 SE ENCUENTRA PRESIONADO, SI NO, SALTAR CON NOP
    call ANTIREBOTE2 ; LLAMAR AL ANTIREBOTE
    BTFSS PORTB, DOWN ; VERIFICAR SI YA SE DEJO DE PRESIONAR RA0
    call DECREMENTO ; SI YA SE DEJO DE PRESIONAR, LLAMAR A FUNCION DE INCREMENTO
    
    BCF RBIF ; LIMPIAR LA BANDERA DEL INTERRUPT POR PULLUPS DEL PORTB
    
    RETURN
    
INT_TMR0:
      // RE INICIO EL TMR0
    BANKSEL TMR0 ; SELCCIONA EL TMR0
    //0.02 SEG = 4*1/1MHZ*256-N*256 Y SE DESPEJO N
    MOVLW 236 ; DELAY DE 20MS
    MOVWF TMR0 ; CARGAR EL VALOR AL TMRO
    BCF T0IF ; LIMPIAMOS LA BANDER DE INTERRUPCION DEL TMR0
    
    INCF TMR0_DISP, 1 ; INCREMENTAMIS LA VARIABLE DEL CONTADOR DE MS
    MOVF TMR0_DISP, W ; MOVEMOS EL VALOR DEL CONTADOR A W
    //20*50 = 1000MS
    SUBLW 50 ; SE LE RESTA 50 A W PARA SABER SI SE HA LLEGADO A 1000MS
    BTFSS ZERO ; CHEQUEAR SE ACTIVA LA BANDERA ZERO,si el bit ZERO es 1 la resta es 0 y se prosigue; si el BIT ZERO es 0 se vuelve a verificar    
    RETURN
    CLRF TMR0_DISP
    INCF PORTB, 1
    ;MOVF PORTB, 0
    ;SUBLW 16
    ;BTFSS ZERO
    ;RETURN
    ;CLRF PORTB
    ;BTFSS TMR0_DISP, 1; SE CHEQUEA SI EL BIT 1 DEL CONTADOR ESTA ENCENDIDO
    ;GOTO INC_UNI
    
    ;BTFSS TMR0_DISP, 3 ; SE REVISA SI EL BIT 3 DEL CONTADOR ESTA EN 1,SI ESTA EN 10 YA PASO 1 SEGUNDO
    ;GOTO INC_UNI
    
    CLRF TMR0_DISP ; CUANDO EL CONTADOR EN SEGUNDOS SE ENCUENTRA EN 10, SE VACIA
    GOTO INC_UNI
    
INC_UNI:
    INCF TMR0_UNIDADES, 1 ; INCREMENTAR LAS UNIDADES DE SEGUNDO
    MOVF TMR0_UNIDADES, W ; MOVER EL VALOR A W PARA CHEQUEAR SI LLEGA A 10
    SUBLW 10		  ; RESTAR 10 PARA REVISAR SI YA CONTO 10 VECES
    BTFSS STATUS, 2	  ; REVISAR LA ZERO FLAG, YA QUE ESTA NOS DICE SI LAS UNIDADES ERAN 10
    RETURN		  ; REGRESAR SI NO ERAN 10
    CLRF TMR0_UNIDADES	  ; SI SI ERAN 10, VACIAR LAS UNIDADES Y PASAR AL INCREMEMTO DE DECENAS
    GOTO INC_DEC
    
INC_DEC:
    INCF TMR0_DECENAS, 1 ; INCREMENTAR LAS DECENAS DE SEGUNDO
    MOVF TMR0_DECENAS, W ; COMPARAR DE IGUAL MANERA QUE LAS UNIDADES, PERO AL CONTAR 6 VECES, PARA 60 SEGUNDOS
    SUBLW 6
    BTFSS STATUS, 2
    RETURN
    CLRF TMR0_UNIDADES   ; VACIAR EL CONTADOR COMPLETO CUANDO LLEGA A 60
    CLRF TMR0_DECENAS	 ; VACIAR EL CONTADOR COMPLETO CUANDO LLEGA A 60
    RETURN
    
ANTIREBOTE1:
    BSF condicion, 0 ; COLOCAR LA CONDICION COMO 1, bit 0
    RETURN ; REGREAR AL LOOP DE CHEQUEO 
    
INCREMENTO:
    BTFSS condicion, 0 ; SI EL PRIMER BIT DE CONDICION NO ES 1, NO PRESIONADO, REGRESAR AL LOOP, SI ES 1, INCREMENTAR
    RETURN ; REGRESA AL LOOP DE CHEQUEO
    INCF PORTA, 1 ;	INCREMENTAR LA VARIABLE DEL CONTADOR DEL DISPLAY
    CLRF condicion ; REINICIAR LA CONDICION
    RETURN ; REGRESA AL CALL DE LA FUNCION LOOP
    
ANTIREBOTE2:
    BSF condicion, 1 ; COLOCAR LA CONDICION COMO 1, bit 1
    RETURN ; REGREAR AL LOOP DE CHEQUEO 
    
DECREMENTO:
    BTFSS condicion, 1 ; SI EL PRIMER BIT DE CONDICION NO ES 1, NO PRESIONADO, REGRESAR AL LOOP, SI ES 1, INCREMENTAR
    RETURN ; REGRESA AL LOOP DE CHEQUEO
    DECF PORTA, 1 ;	DECREMENTAR LA VARIABLE DEL CONTADOR DEL DISPLAY
    CLRF condicion ; REINICIAR LA CONDICION
    RETURN ; REGRESA AL CALL DE LA FUNCION LOOP     
    
;----------- Código Principal ----------
PSECT CODE, delta=2, abs
 ORG 100h

 TABLA:
    CLRF PCLATH ; limpiar pclath
    BSF PCLATH, 0 ; estbalece el bit 0 de pclath, es decir en 01
    
    ANDLW 0x0F     ; 15 A W PARA ESTABLECER LIMITE Y QUE W SOLO TENGA LOS 4 BITS MENOS SINIFICATIVOS
    ADDWF PCL      ;SUMA EL PCL Y W, ASI PC = PCLATH+PCL+W, INDICA POSICION EN PC
    
    ; TABLA PARA ANODO COMUN, 
    ;BITS DP G F E D C B A
    RETLW 11000000B ;0
    RETLW 11111001B ;1
    RETLW 10100100B ;2
    RETLW 10110000B ;3
    RETLW 10011001B ;4
    RETLW 10010010B ;5
    RETLW 10000010B ;6
    RETLW 11111000B ;7
    RETLW 10000000B ;8
    RETLW 10011000B ;9
    ;RETLW 10001000B ;A
    ;RETLW 10000011B ;B
    ;RETLW 11000110B ;C
    ;RETLW 10100001B ;D
    ;RETLW 10000110B ;E
    ;RETLW 10001110B ;F 

main:
    call setup_io
    call setup_rbpu
    call setup_osc
    call setup_iocb
    call setup_tmr0
    
    ; VACIAR VARIABLES DEL TMR0 PARA QUE INICIEN TODAS EN 0
    CLRF TMR0_DISP
    CLRF TMR0_UNIDADES
    CLRF TMR0_DECENAS
    
    
    
;----------- Loop Principal ----------    
loop: 
    MOVF TMR0_UNIDADES, 0
    CALL TABLA
    MOVWF PORTC
    MOVF TMR0_DECENAS, 0
    CALL TABLA
    MOVWF PORTD
	
    GOTO loop

    
;----------- Subrutinas --------------
setup_io:
    ; ESTABLECER TODOS LOS PINES COMO DIGITALES
    BANKSEL ANSEL ; BUSCAR BANCO DE ANSEL
    
    CLRF ANSEL ; ESTABLECER ANALOGICAS COMO 0
    CLRF ANSELH ; ESTABLECER ANALOGICAS COMO 0 
 
    ; ESTABLECER TODOS LOS PINES COMO ENTRADAS/SALIDAS
    BANKSEL TRISA     ;BUSCAR BANCO DE TRIS 
   
    BCF TRISA, 0      ; RA0 COMO SALIDA, CONTADOR BOTONES
    BCF TRISA, 1      ; RA1 COMO SALIDA
    BCF TRISA, 2      ; RA2 COMO SALIDA
    BCF TRISA, 3      ; RA3 COMO SALIDA
    
    BCF TRISB, 0      ; RB0 COMO SALIDA, CONTADOR TMR0
    BCF TRISB, 1      ; RB1 COMO SALIDA
    BCF TRISB, 2      ; RB2 COMO SALIDA 
    BCF TRISB, 3      ; RB3 COMO SALIDA
    
    BSF TRISB, UP     ; RB6 COMO ENTRADA, BOTONES
    BSF TRISB, DOWN   ; RB7 COMO ENTRADA
    
    CLRF TRISC        ; PUERTO C COMO SALIDA, DISPLAY UNIDADES SEGUNDOS
    
    CLRF TRISD        ; PUERTO C COMO SALIDA, DISPLAY DECENAS SEGUNDOS
    
    ; INICIAR TODOS LOS PUERTOS
    BANKSEL PORTA     ; BANCO DE PUERTOS
    
    CLRF PORTA        ; INICIAR PUERTO A
    CLRF PORTB        ; INICIAR PUERTO B
    CLRF PORTC        ; INICIAR PUERTO C
    CLRF PORTD        ; INICIAR PUERTO D
    ;CLRF PORTE        ; INICIAR PUERTO E
    
    RETURN
    
setup_rbpu:           ; ESTABLECER LOS PULLUPS DESEADOS
    BANKSEL TRISA
    BCF OPTION_REG, 7 ; HABILITAR LOS PULLUPS DEL PORTB 
    BSF WPUB, UP      ; ESTABLECER LOS PINES QUE SON PULLUPS
    BSF WPUB, DOWN    ; ESTABLECER LOS PINES QUE SON PULLUPS
    
    RETURN
    
setup_osc:
    ; ESTABLECER OSCILADOR DESEADO, EN ESTE CASO INTERNO A 1 MHz
    BANKSEL OSCCON
   
    BSF SCS ; SELECCIONAR EL OSCILADOR INTERNO
    
    BSF IRCF2 ; ESTABLECER COMO 100 EL IRCF, QUE ES I MHz
    BCF IRCF1 ; ESTABLECER COMO 100 EL IRCF
    BCF IRCF0 ; ESTABLECER COMO 100 EL IRCF
    
    RETURN
    
setup_iocb:   ; HABILITAR LAS INTERRUPCIONES
    BANKSEL TRISA
    BSF IOCB, UP    ; HABILITAR LOS PINES INDIVIDUALES DE LAS INTERRUPCIONES
    BSF IOCB, DOWN  ; HABILITAR LOS PINES INDIVIDUALES DE LAS INTERRUPCIONES
    BSF RBIE	    ; HABILITAR INTERRUPCIONES POR PULLUPS EN PORTB
    BSF GIE         ; HABILITAR INTERRUPCIONES GLOBALES
    BSF T0IE
    BCF T0IF
    
    RETURN
    
setup_tmr0:
        ;------------CONFIGURACION DEL TMR0----------------------
    BANKSEL OPTION_REG ; BUSCAR BANCO DE OPTION REGISTER
    ; PARA PRESCALER EN 256, SE NECESITA PS(2:0) COMO 111
    BCF PSA ;SE LE ASIGNA EL PRESCALER AL TIMER0, 1 SERIA WATCHDOG 
    BSF PS2 ; PS2 EN 1
    BSF PS1; PS1 EN 1
    BSF PS0 ; PS0 EN 1
    BCF T0CS ; CON T0CS EN 0, ESTE SERVIRA COMO TIMER
    
    ;-----------------TIMER--------------------------
    BANKSEL TMR0 ; BUSCAR EL BANCO DE TMR0
    ; 0.02 SEG = 4*1/1MHZ*(256-N)*256, despejar para N
    ; N = 236.46875
    MOVLW 236 ; ESTABLECER W COMO EL 61 NECESARIO PARA EL TMR0
    MOVWF TMR0 ; CARGAR EL VALOR DE W AL TMR0
    BCF T0IF ; VACIAR O LIMPIAR LA BANDERA DE OVERFLOW DEL TMR0
    
    INCF TMR0_DISP  ; INCREMENTAR LA VARIABLE QUE SE VA A ENVIAR AL DISPLAY
    
    RETURN   
    
    END
